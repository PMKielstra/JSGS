package com.golfscriptcompiler.builtins;

import java.util.Hashtable;

import com.golfscriptcompiler.tokenizer.Token;

public class BuiltinManager {
	
	private static Hashtable<String, Builtin> builtins;
	
	public static void init(){
		builtins = new Hashtable<String, Builtin>();
		builtins.put("~", new Builtin("tilde", "function (){\r\n\tvar topOfStack = stack.pop(); //We will be using this no matter what.\r\n\tswitch(typeof topOfStack){\r\n\t\tcase \"number\": //If it\'s a number,\r\n\t\t\tstack.push(~topOfStack); //Bitwise not.\r\n\t\t\tbreak;\r\n\t\tcase \"function\": //If it\'s a function,\r\n\t\t\ttopOfStack(); //Call it.\r\n\t\t\tbreak;\r\n\t\tcase \"object\": //If it\'s an array,\r\n\t\t\tif(topOfStack instanceof Array){\r\n\t\t\t\ttopOfStack.forEach(function(e){ //Dump it.\r\n\t\t\t\t\tstack.push(e);\r\n\t\t\t\t})\r\n\t\t\t}\r\n\t\t\tbreak;\r\n\t\tdefault: //If it\'s none of those,\r\n\t\t\tstack.push(topOfStack); //This never happened.\r\n\t}\r\n}"));
		builtins.put("!", new Builtin("exclamation", "function (){ //Slightly different from JS not, so we use our own implementation.\r\n\tstack.push([]);\r\n\tvar topOfStack = stack.pop();\r\n\tswitch(topOfStack){\r\n\t\tcase 0: //Falsy values.\r\n\t\tcase \"\":\r\n\t\t\tstack.push(1);\r\n\t\t\tbreak;\r\n\t\tdefault:\r\n\t\t\t//Can\'t check for empty array in case statement, so we use a more complicated if statement.\r\n\t\t\tif(topOfStack instanceof Array && topOfStack.length == 0){\r\n\t\t\t\tstack.push(1);\r\n\t\t\t}else{\r\n\t\t\t\tstack.push(0);\r\n\t\t\t}\r\n\t}\r\n}"));
		builtins.put("@", new Builtin("atSign", "function (){\r\n\t//I\'d like to use indexOf here, but IE7-8 don\'t support it.\r\n\tvar first = stack.pop();\r\n\tvar second = stack.pop();\r\n\tvar third = stack.pop();\r\n\tstack.push(second);\r\n\tstack.push(first);\r\n\tstack.push(third);\r\n}"));
		builtins.put("$", new Builtin("dollar", "function (){\r\n\tvar topOfStack = stack.pop();\r\n\tswitch(typeof topOfStack){\r\n\t\tcase \"number\": //If n is an integer, copy nth item from $tack.\r\n\t\t\tvar indexOfLastItem = stack.length - 1;\r\n\t\t\tstack.push(stack[indexOfLastItem - topOfStack]);\r\n\t\t\tbreak;\r\n\t\tcase \"string\": //For arrays and strings, $ort.\r\n\t\t\tvar array = stack.push(topOfStack.split(\"\").sort().join(\"\"));\r\n\t\t\tbreak;\r\n\t\tcase \"object\":\r\n\t\t\tif(topOfStack instanceof Array) stack.push(topOfStack.sort());\r\n\t\t\tbreak;\r\n\t\tcase \"function\": //For blocks with arrays underneath, sort by some mapping.\r\n\t\t\tvar underneath = stack.pop();\r\n\t\t\tswitch(typeof underneath){\r\n\t\t\t\tcase \"string\":\r\n\t\t\t\t\tfunction srt(a, b){\r\n\t\t\t\t\t\tstack.push(a-b);\r\n\t\t\t\t\t\ttopOfStack();\r\n\t\t\t\t\t\treturn stack.pop();\r\n\t\t\t\t\t}\r\n\t\t\t\t\tvar array = underneath.split(\"\");\r\n\t\t\t\t\tarray = array.map(function(e){return e.charCodeAt(0)});\r\n\t\t\t\t\tarray.sort(srt); //Convert to numbers and sort.\r\n\t\t\t\t\tarray = array.map(function(e){return String.fromCharCode(e)});\r\n\t\t\t\t\tstack.push(array.join(\"\"));\r\n\t\t\t\t\tbreak;\r\n\t\t\t\tcase \"object\":\r\n\t\t\t\t\tif(underneath instanceof Array){\r\n\t\t\t\t\t\tfunction srt(a, b){\r\n\t\t\t\t\t\t\tstack.push(a-b);\r\n\t\t\t\t\t\t\ttopOfStack();\r\n\t\t\t\t\t\t\treturn stack.pop();\r\n\t\t\t\t\t\t}\r\n\t\t\t\t\t\tstack.push(underneath.sort(srt));\r\n\t\t\t\t\t}else{\r\n\t\t\t\t\t\tstack.push(underneath); //If we have the wrong args, just push the popped elements back onto the stack.\r\n\t\t\t\t\t\tstack.push(topOfStack);\r\n\t\t\t\t\t}\r\n\t\t\t}\r\n\t\t\tbreak;\r\n\t\tdefault:\r\n\t\t\t\t  stack.push(topOfStack);\r\n\t\t}\r\n}"));
		builtins.put("+", new Builtin("plus", "function () {\r\n\tvar first = stack.pop();\r\n\tvar second = stack.pop();\r\n\tif ((typeof first) == \"function\" || (typeof second) == \"function\") {\r\n\t\tif (typeof first == \"function\" && typeof second == \"function\") { //Concatenate functions.\r\n\t\t\tstack.push(function () {\r\n\t\t\t\tsecond();\r\n\t\t\t\tfirst();\r\n\t\t\t});\r\n\t\t} else if (typeof first == \"function\") {\r\n\t\t\tstack.push(function () {\r\n\t\t\t\tstack.push(second);\r\n\t\t\t\tfirst();\r\n\t\t\t});\r\n\t\t} else { //They aren\'t both functions, the first isn\'t a function, so the second must be.\r\n\t\t\tstack.push(function () {\r\n\t\t\t\tsecond();\r\n\t\t\t\tstack.push(first);\r\n\t\t\t});\r\n\t\t}\r\n\t} else if (first instanceof Array || second instanceof Array) {\r\n\t\tif (first instanceof Array && second instanceof Array) {\r\n\t\t\tstack.push(second.concat(first));\r\n\t\t} else if (second instanceof Array) {\r\n\t\t\tsecond.push(first);\r\n\t\t\tstack.push(second); //Technically, we should do some complicated coercion here.  Instead, I\'m being a tad lazy.\r\n\t\t} else { //The first one has to be the array.\r\n\t\t\tfirst.unshift(second);\r\n\t\t\tstack.push(first);\r\n\t\t}\r\n\t}else{ stack.push(second + first);}\r\n}"));
		builtins.put("-", new Builtin("minus", "function () {\r\n\tvar first = stack.pop();\r\n\tvar second = stack.pop();\r\n\tif (first instanceof Array || second instanceof Array) {\r\n\t\tif(!(first instanceof Array)) first = [first];\r\n\t\tif(!(second instanceof Array)) second = [second];\r\n\t\tvar temp = new Array();\r\n\t\tsecond.forEach(function(e){\r\n\t\t\tvar contains = false;\r\n\t\t\tfirst.forEach(function(f){\r\n\t\t\t\tif(e == f) contains = true;\r\n\t\t\t});\r\n\t\t\tif(!contains) temp.push(e);\r\n\t\t});\r\n\t\tstack.push(temp);\r\n\t} else {\r\n\t\tstack.push(second - first);\r\n\t}\r\n}"));
		builtins.put("*", new Builtin("star", "function () {\r\n\tvar first = stack.pop();\r\n\tvar second = stack.pop();\r\n\t\r\n\tfunction priority(x) {\r\n\t\tif (typeof x == \"function\") return 4;\r\n\t\tif (typeof x == \"string\") return 3;\r\n\t\tif (x instanceof Array) return 2;\r\n\t\tif (typeof x == \"number\") return 1;\r\n\t\treturn 0;\r\n\t}\r\n\tif (priority(second) > priority(first)) {\r\n\t\tvar temp = first;\r\n\t\tfirst = second;\r\n\t\tsecond = temp;\r\n\t}\r\n\t\r\n\tif (typeof first == \"function\") {\r\n\t\tif (typeof second == \"number\") {\r\n\t\t\tfor (i = 0; i < second; i++) {\r\n\t\t\t\tfirst();\r\n\t\t\t}\r\n\t\t} else if (typeof second == \"string\" || second instanceof Array) {\r\n\t\t\tif (typeof second == \"string\") second = second.split(\"\");\r\n\t\t\tstack.push(second[0]);\r\n\t\t\tsecond = second.slice(1, second.length);\r\n\t\t\tsecond.forEach(function (e) {\r\n\t\t\t\tif (typeof e == \"string\") e = e.charCodeAt(0);\r\n\t\t\t\tstack.push(e);\r\n\t\t\t\tfirst();\r\n\t\t\t});\r\n\t\t}\r\n\t} else if (typeof second == \"number\") {\r\n\t\tif (typeof first == \"string\") {\r\n\t\t\tvar s = \"\";\r\n\t\t\tfor (i = 0; i < second; i++) s += first;\r\n\t\t\tstack.push(s);\r\n\t\t} else if (first instanceof Array) {\r\n\t\t\tvar a = new Array();\r\n\t\t\tfor (i = 0; i < second; i++) a = a.concat(first);\r\n\t\t\tstack.push(a);\r\n\t\t}\r\n\t} else if (typeof second == \"string\") {\r\n\t\tstack.push(second.split(\"\").join(first)); //First will be a string.  It is either a string or a function, because we order first and second by priority, and it isn\'t a function, because we did that case further up.\r\n\t} else if (second instanceof Array) {\r\n\t\tif (first instanceof Array) {\r\n\t\t\tvar third = new Array();\r\n\t\t\tfor (i = 0; i < second.length; i++) {\r\n\t\t\t\tif (second[i] instanceof Array && second[i].length == 1) second[i] = second[i][0];\r\n\t\t\t\tthird.push(second[i]);\r\n\t\t\t\tif (i != second.length - 1) third = third.concat(first);\r\n\t\t\t}\r\n\t\t\tstack.push(third);\r\n\t\t} else if (typeof first == \"string\") {\r\n\t\t\tstack.push(second.join(first)); //Not exact implementation, but this is how JS would do it.\r\n\t\t}\r\n\t} else stack.push(first * second);\r\n\t\r\n}"));
		builtins.put("/", new Builtin("slash", "function () {\r\n\tvar first = stack.pop();\r\n\tvar second = stack.pop();\r\n\t\r\n\tfunction priority(x) {\r\n\t\tif (typeof x == \"function\") return 4;\r\n\t\tif (typeof x == \"string\") return 3;\r\n\t\tif (x instanceof Array) return 2;\r\n\t\tif (typeof x == \"number\") return 1;\r\n\t\treturn 0;\r\n\t}\r\n\tif (priority(second) < priority(first)) {\r\n\t\tvar temp = first;\r\n\t\tfirst = second;\r\n\t\tsecond = temp;\r\n\t}\r\n\tif (second instanceof Array) {\r\n\t\tif (first instanceof Array) {\r\n\t\t\tfunction splitArray(array, split) {\r\n\t\t\t\tvar newArray = new Array();\r\n\t\t\t\tfor (i = 0; i < array.length; i++) {\r\n\t\t\t\t\tif (arrayEquals(array.slice(i, split.length + i), split)) {\r\n\t\t\t\t\t\ti += split.length - 1;\r\n\t\t\t\t\t} else newArray.push(array[i]);\r\n\t\t\t\t}\r\n\t\t\t\treturn newArray;\r\n\t\r\n\t\t\t\tfunction arrayEquals(arr1, arr2) {\r\n\t\t\t\t\tif (arr1.length != arr2.length) return false;\r\n\t\t\t\t\tfor (count = 0; count < arr1.length; count++) {\r\n\t\t\t\t\t\tif (arr1[count] != arr2[count]) return false;\r\n\t\t\t\t\t}\r\n\t\t\t\t\treturn true;\r\n\t\t\t\t}\r\n\t\t\t}\r\n\t\t\tsecond = splitArray(second, first);\r\n\t\t\tvar third = new Array();\r\n\t\t\tsecond.forEach(function (e) {\r\n\t\t\t\tif (e) {\r\n\t\t\t\t\tthird.push(e);\r\n\t\t\t\t}\r\n\t\t\t});\r\n\t\t\tstack.push(third);\r\n\t\t} else if (typeof first == \"number\") {\r\n\t\t\tvar third = new Array();\r\n\t\t\twhile (second.length > 0) {\r\n\t\t\t\tthird.push(second.splice(0, first));\r\n\t\t\t}\r\n\t\t\tstack.push(third);\r\n\t\t}\r\n\t} else if (typeof second == \"function\") {\r\n\t\tif (first instanceof Array) {\r\n\t\t\tfirst.forEach(function (e) {\r\n\t\t\t\tstack.push(e);\r\n\t\t\t\tsecond();\r\n\t\t\t});\r\n\t\t} else if (typeof first == \"function\") {\r\n\t\t\tvar third = new Array();\r\n\t\t\tvar top = stack.pop();\r\n\t\t\tstack.push(top);\r\n\t\t\tstack.push(top);\r\n\t\t\twhile (second()) {\r\n\t\t\t\tfirst();\r\n\t\t\t\ttop = stack.pop();\r\n\t\t\t\tthird.push(top);\r\n\t\t\t\tstack.push(top);\r\n\t\t\t\tstack.push(top);\r\n\t\t\t}\r\n\t\t\tstack.push(third.slice(0, third.length - 1));\r\n\t\t}\r\n\t}else if(typeof first == \"string\" && typeof second == \"string\"){\r\n\t\tstack.push(second.split(first));\r\n\t}else stack.push(Math.round(second / first));\r\n}"));
		builtins.put("%", new Builtin("percent", "function () {\r\n\tvar first = stack.pop();\r\n\tvar second = stack.pop();\r\n\r\n\tfunction priority(x) {\r\n\t\tif (typeof x == \"function\") return 4;\r\n\t\tif (typeof x == \"string\") return 3;\r\n\t\tif (x instanceof Array) return 2;\r\n\t\tif (typeof x == \"number\") return 1;\r\n\t\treturn 0;\r\n\t}\r\n\tif (priority(second) < priority(first)) {\r\n\t\tvar temp = first;\r\n\t\tfirst = second;\r\n\t\tsecond = temp;\r\n\t}\r\n\tif (second instanceof Array) {\r\n\t\tif (first instanceof Array) {\r\n\t\t\tfunction splitArray(array, split) {\r\n\t\t\t\tvar newArray = new Array();\r\n\t\t\t\tfor (i = 0; i < array.length; i++) {\r\n\t\t\t\t\tif (arrayEquals(array.slice(i, split.length + i), split)) {\r\n\t\t\t\t\t\ti += split.length - 1;\r\n\t\t\t\t\t} else newArray.push(array[i]);\r\n\t\t\t\t}\r\n\t\t\t\treturn newArray;\r\n\r\n\t\t\t\tfunction arrayEquals(arr1, arr2) {\r\n\t\t\t\t\tif (arr1.length != arr2.length) return false;\r\n\t\t\t\t\tfor (count = 0; count < arr1.length; count++) {\r\n\t\t\t\t\t\tif (arr1[count] != arr2[count]) return false;\r\n\t\t\t\t\t}\r\n\t\t\t\t\treturn true;\r\n\t\t\t\t}\r\n\t\t\t}\r\n\t\t\tsecond = splitArray(second, first);\r\n\t\t\tvar third = new Array();\r\n\t\t\tsecond.forEach(function (e) {\r\n\t\t\t\tif (e) {\r\n\t\t\t\t\tthird.push(e);\r\n\t\t\t\t}\r\n\t\t\t});\r\n\t\t\tstack.push(third);\r\n\t\t} else if (typeof first == \"number\") {\r\n\t\t\tvar third = new Array()\r\n\t\t\tfor (i = 0; i < second.length; i += first) {\r\n\t\t\t\tthird.push(second[i]);\r\n\t\t\t}\r\n\t\t\tstack.push(third);\r\n\t\t}\r\n\t} else if (first instanceof Array && typeof second == \"function\") {\r\n\t\tvar len = stack.length;\r\n\t\tvar third = new Array();\r\n\t\tfirst.forEach(function (e) {\r\n\t\t\tstack.push(e);\r\n\t\t\tsecond();\r\n\t\t\tvar newLen = stack.length;\r\n\t\t\tvar temp = new Array();\r\n\t\t\twhile (stack.length != len) {\r\n\t\t\t\ttemp.push(stack.pop());\r\n\t\t\t}\r\n\t\t\ttemp.reverse();\r\n\t\t\tif (third.length != 0) {\r\n\t\t\t\tthird = third.concat(temp);\r\n\t\t\t} else third = temp;\r\n\t\t});\r\n\t\tstack.push(third);\r\n\t} else if (typeof first == \"string\" && typeof second == \"string\") {\r\n\t\tvar third = new Array();\r\n\t\tsecond.split(first).forEach(function (e) {\r\n\t\t\tif (e != \"\") third.push(e);\r\n\t\t});\r\n\t\tstack.push(third);\r\n\t} else stack.push(second % first);\r\n}"));
		builtins.put("|", new Builtin("pipe", "function () {\r\n\tvar first = stack.pop();\r\n\tvar second = stack.pop();\r\n\tif (first instanceof Array && second instanceof Array) { //Setwise OR\r\n\t\tfirst = second.concat(first);\r\n\t\tvar result = new Array();\r\n\t\tfirst.forEach(function (e) {\r\n\t\t\tif (!contains(e, result)) result.push(e);\r\n\t\t});\r\n\t\tstack.push(result);\r\n\t} else stack.push(first | second);\r\n\r\n\tfunction contains(item, arr) {\r\n\t\tfor (i = 0; i < arr.length; i++)\r\n\t\tif (arr[i] == item || (arr[i] + \"\") == (item + \"\")) {\r\n\t\t\treturn true;\r\n\t\t}\r\n\t\treturn false;\r\n\t}\r\n}"));
		builtins.put("&", new Builtin("ampersand", "function () {\r\n\tvar first = stack.pop();\r\n\tvar second = stack.pop();\r\n\tif (first instanceof Array && second instanceof Array) { //Setwise AND\r\n\t\tfirst = first.filter(function (item, pos) { //Ensure that the arrays contain no duplicate elements.\r\n\t\t\treturn !contains(item, first.slice(pos + 1, first.length));\r\n\t\t});\r\n\t\tsecond = second.filter(function (item, pos) {\r\n\t\t\treturn !contains(item, second.slice(pos + 1, second.length));\r\n\t\t});\r\n\t\tvar result = new Array();\r\n\t\tsecond.forEach(function (e) {\r\n\t\t\tif (contains(e, first)) {\r\n\t\t\t\tresult.push(e); //Add it to the result and remove it from the array (so that [1,1] & [1] doesn\'t evaluate to [1,1] when the second array has only one element.)\r\n\t\t\t\tfirst.splice(first.indexOf(e), 1);\r\n\t\t\t}\r\n\t\t});\r\n\t\tstack.push(result);\r\n\t} else stack.push(first & second); \r\n\r\n\tfunction contains(item, arr) {\r\n\t\tfor (i = 0; i < arr.length; i++)\r\n\t\tif (arr[i] == item || (arr[i] + \"\") == (item + \"\")) {\r\n\t\t\treturn true;\r\n\t\t}\r\n\t\treturn false;\r\n\t}\r\n\r\n}"));
		builtins.put("^", new Builtin("caret", "function () {\r\n\tvar first = stack.pop();\r\n\tvar second = stack.pop();\r\n\tif (first instanceof Array && second instanceof Array) { //Setwise XOR\r\n\t\tvar result = new Array();\r\n\t\tfirst = first.filter(function (item, pos) { //Ensure that the arrays contain no duplicate elements.\r\n\t\t\treturn !contains(item, first.slice(pos + 1, first.length));\r\n\t\t});\r\n\t\tsecond = second.filter(function (item, pos) {\r\n\t\t\treturn !contains(item, second.slice(pos + 1, second.length));\r\n\t\t});\r\n\t\tsecond.forEach(function (e) {\r\n\t\t\tif (contains(e, first)) {\r\n\t\t\t\tfirst.splice(first.indexOf(e), 1);\r\n\t\t\t} else result.push(e);\r\n\t\t});\r\n\t\tresult = result.concat(first); //Add in the elements that were only in the first array.\r\n\t\tstack.push(result);\r\n\r\n\t} else stack.push(first ^ second); \r\n\tfunction contains(item, arr) {\r\n\t\tfor (i = 0; i < arr.length; i++)\r\n\t\tif (arr[i] == item || (arr[i] + \"\") == (item + \"\")) {\r\n\t\t\treturn true;\r\n\t\t}\r\n\t\treturn false;\r\n\t}\r\n}"));
		builtins.put("[", new Builtin("startArray", "function () {\r\n\twindow.stackSize = stack.length; //Global variable so that endArray can access it too.\r\n}"));
		builtins.put("]", new Builtin("endArray", "function () {\r\n\tvar arr = new Array();\r\n\tvar l = stack.length - 1;\r\n\tfor (i = l; i >= 0 && stack[i].isStartOfArray != true; i--) {\r\n\t\tarr.push(stack.pop());\r\n\t}\r\n\tif (stack.length > 0) stack.pop(); //Get rid of array start marker.\r\n\tarr.reverse();\r\n\tstack.push(arr);\r\n}"));
		builtins.put("\\", new Builtin("backslash", "function (){\r\n\tvar first = stack.pop();\r\n\tvar second = stack.pop();\r\n\tstack.push(first);\r\n\tstack.push(second);\r\n}"));
		builtins.put(";", new Builtin("semicolon", "function (){\r\n\tstack.pop();\r\n}"));
		builtins.put(">", new Builtin("greaterThan", "function () {\r\n\tvar first = stack.pop();\r\n\tvar second = stack.pop();\r\n\tvar needsRecombining = false;\r\n\tif(typeof first == \"string\" || typeof second == \"string\") needsRecombining = true;\r\n\tif (typeof first == \"string\") first = first.split(\"\");\r\n\tif (typeof second == \"string\") second = second.split(\"\");\r\n\tif (typeof first == typeof second) {\r\n\t\tif (second < first) {\r\n\t\t\tstack.push(1);\r\n\t\t} else stack.push(0);\r\n\t} else if (typeof first == \"number\" && second instanceof Array) {\r\n\t\tsecond = second.slice(first);\r\n\t\tif(needsRecombining) second = second.join(\"\");\r\n\t\tstack.push(second);\r\n\t} else if (typeof second == \"number\" && first instanceof Array) {\r\n\t\tfirst = first.slice(second);\r\n\t\tif(needsRecombining) first = first.join(\"\");\r\n\t\tstack.push(first);\r\n\t} else {\r\n\t\tstack.push(second);\r\n\t\tstack.push(first);\r\n\t}\r\n}"));
		builtins.put("<", new Builtin("lessThan", "function () {\r\n\tvar first = stack.pop();\r\n\tvar second = stack.pop();\r\n\tvar needsRecombining = false;\r\n\tif(typeof first == \"string\" || typeof second == \"string\") needsRecombining = true;\r\n\tif (typeof first == \"string\") first = first.split(\"\");\r\n\tif (typeof second == \"string\") second = second.split(\"\");\r\n\tif (typeof first == typeof second) {\r\n\t\tif (second > first) {\r\n\t\t\tstack.push(1);\r\n\t\t} else stack.push(0);\r\n\t} else if (typeof first == \"number\" && second instanceof Array) {\r\n\t\tsecond = second.slice(0, first);\r\n\t\tif(needsRecombining) second = second.join(\"\");\r\n\t\tstack.push(second);\r\n\t} else if (typeof second == \"number\" && first instanceof Array) {\r\n\t\tfirst = first.slice(0, second);\r\n\t\tif(needsRecombining) first = first.join(\"\");\r\n\t\tstack.push(first);\r\n\t} else {\r\n\t\tstack.push(second);\r\n\t\tstack.push(first);\r\n\t}\r\n}"));
		builtins.put("=", new Builtin("equalTo", "function () {\r\n\tvar first = stack.pop();\r\n\tvar second = stack.pop();\r\n\tif (typeof first == typeof second) {\r\n\t\tif (second == first) {\r\n\t\t\tstack.push(1);\r\n\t\t} else stack.push(0);\r\n\t} else if (typeof first == \"number\" && second instanceof Array && first < second.length) {\r\n\t\tstack.push(second[first]);\r\n\t} else if (typeof second == \"number\" && first instanceof Array && second < first.length) {\r\n\t\tstack.push(first[second]);\r\n\t} else {\r\n\t\tstack.push(second);\r\n\t\tstack.push(first);\r\n\t}\r\n}"));
		builtins.put(",", new Builtin("comma", "function () {\r\n\tvar first = stack.pop();\r\n\tif (typeof first == \"number\") {\r\n\t\tvar arr = Array.apply(null, Array(first)); //Create array.\r\n\t\tarr = arr.map(function (x, i) {\r\n\t\t\treturn i;\r\n\t\t}); //Fill with values.\r\n\t\tstack.push(arr);\r\n\t} else if (first instanceof Array) {\r\n\t\tstack.push(first.length);\r\n\t} else if (typeof first == \"function\") {\r\n\t\tvar second = stack.pop(); //We only need second here, so I didn\'t create it up at the top of this function.\r\n\t\tif (second instanceof Array) {\r\n\t\t\tvar result = new Array();\r\n\t\t\tsecond.forEach(function (e) {\r\n\t\t\t\tstack.push(e);\r\n\t\t\t\tfirst();\r\n\t\t\t\tif (stack.pop()) result.push(e);\r\n\t\t\t});\r\n\t\t\tstack.push(result);\r\n\t\t} else {\r\n\t\t\tstack.push(second);\r\n\t\t\tstack.push(first);\r\n\t\t}\r\n\t} else stack.push(first);\r\n}"));
		builtins.put(".", new Builtin("period", "function (){\r\n\tvar first = stack.pop();\r\n\tstack.push(first);\r\n\tstack.push(first);\r\n}"));
		builtins.put("?", new Builtin("questionMark", "function () {\r\n\tvar first = stack.pop();\r\n\tvar second = stack.pop();\r\n\tif (typeof first == \"number\" && typeof second == \"number\") {\r\n\t\tstack.push(Math.pow(second, first));\r\n\t} else if (first instanceof Array) {\r\n\t\tstack.push(first.indexOf(second));\r\n\t} else if (typeof first == \"function\" && second instanceof Array) {\r\n\t\tfor (i = 0; i < second.length; i++) {\r\n\t\t\tstack.push(second[i]);\r\n\t\t\tfirst();\r\n\t\t\tif (stack.pop()) {\r\n\t\t\t\tstack.push(second[i]);\r\n\t\t\t\tbreak;\r\n\t\t\t}\r\n\t\t}\r\n\t} else {\r\n\t\tstack.push(second);\r\n\t\tstack.push(first);\r\n\t}\r\n}"));
		builtins.put("(", new Builtin("openBracket", "function (){\r\n\tvar topOfStack = stack.pop();\r\n\tif(typeof topOfStack == \"number\"){\r\n\t\tstack.push(topOfStack - 1);\r\n\t}else if(topOfStack instanceof Array){\r\n\t\tvar firstElement = topOfStack[0];\r\n\t\tstack.push(topOfStack.slice(1, topOfStack.length));\r\n\t\tstack.push(firstElement);\r\n\t}\r\n}"));
		builtins.put(")", new Builtin("closeBracket", "function (){\r\n\tvar topOfStack = stack.pop();\r\n\tif(typeof topOfStack == \"number\"){\r\n\t\tstack.push(topOfStack + 1);\r\n\t}else if(topOfStack instanceof Array){\r\n\t\tvar firstElement = topOfStack.pop();\r\n\t\tstack.push(topOfStack);\r\n\t\tstack.push(firstElement);\r\n\t}\r\n}"));
		builtins.put("n", new Builtin("n", "function () {\r\n\tstack.push(\"\\r\\n\");\r\n}"));
		builtins.put("puts", new Builtin("puts", "function () {\r\n\tprint();\r\n\tstack.push(\"\\r\n\");\r\n\tprint();\r\n}"));
		builtins.put("rand", new Builtin("rand", "function () {\r\n\tstack.push(Math.floor(Math.random() * stack.pop()));\r\n}"));
		builtins.put("do", new Builtin("GSdo", "function () { //do is a reserved word in JS\r\n\tvar topOfStack = stack.pop();\r\n\tdo {\r\n\t\ttopOfStack();\r\n\t} while (stack.pop());\r\n}"));
		builtins.put("while", new Builtin("GSwhile", "function () { //while is a reserved word in JS\r\n\tvar topOfStack = stack.pop();\r\n\tvar condition = stack.pop();\r\n\tcondition();\r\n\twhile(stack.pop()){\r\n\t\ttopOfStack();\r\n\t\tcondition();\r\n\t}\r\n}"));
		builtins.put("until", new Builtin("GSuntil", "function () { //gsuntil because the while loop was called gswhile and the do loop was called gsdowhile\r\n\tvar topOfStack = stack.pop();\r\n\tvar condition = stack.pop();\r\n\tcondition();\r\n\twhile(!stack.pop()){\r\n\t\ttopOfStack();\r\n\t\tcondition();\r\n\t}\r\n}"));
		builtins.put("if", new Builtin("GSif", "function () { //if is a reserved word in JS\r\n\tvar second = stack.pop();\r\n\tvar first = stack.pop();\r\n\tvar condition = stack.pop();\r\n\tif(condition){\r\n\t\tif(typeof first == \"function\"){\r\n\t\t\tfirst();\r\n\t\t}else stack.push(first);\r\n\t}else{\r\n\t\tif(typeof second == \"function\"){\r\n\t\t\tsecond();\r\n\t\t}else stack.push(first);\r\n\t}\r\n}"));
		builtins.put("abs", new Builtin("abs", "function () {\r\n\tstack.push(Math.abs(stack.pop()));\r\n}"));
		builtins.put("zip", new Builtin("zip", "function () {\r\n\tvar topOfStack = stack.pop();\r\n\tif (!(topOfStack instanceof Array)) { //Quick sanity check.\r\n\t\tstack.push(topOfStack);\r\n\t\treturn;\r\n\t}\r\n\tvar needsRecombining = false;\r\n\ttopOfStack = topOfStack.map(function (value) { //Convert string to array.\r\n\t\tif (typeof value == \"string\") {\r\n\t\t\tneedsRecombining = true;\r\n\t\t\treturn value.split(\"\");\r\n\t\t} else return value;\r\n\t});\r\n\tvar maxLength = topOfStack.sort(function (a, b) {\r\n\t\treturn b.length - a.length;\r\n\t})[0].length;\r\n\tvar transpose = new Array();\r\n\tfor (i = 0; i < maxLength; i++) {\r\n\t\ttranspose[i] = new Array();\r\n\t\tfor (j = 0; j < topOfStack.length; j++) {\r\n\t\t\tif (topOfStack[j][i]) transpose[i][j] = topOfStack[j][i];\r\n\t\t}\r\n\t}\r\n\tif (needsRecombining) {\r\n\t\tfor (var i = 0; i < transpose.length; i++) {\r\n\t\t\ttranspose[i] = transpose[i].join(\"\");\r\n\t\t}\r\n\t}\r\n\tstack.push(transpose);\r\n}"));
		builtins.put("base", new Builtin("base", "function () {\r\n\tvar baseToUse = stack.pop();\r\n\tvar num = stack.pop();\r\n\tvar result;\r\n\tif(num instanceof Array){ //Numbers to be converted to base 10 are passed as arrays.\r\n\t\tstack.push(parseInt(num.join(\"\"), baseToUse));\r\n\t}else{ //Numbers to be converted away from base 10 are passed as integers.\r\n\t\tvar array = num.toString(baseToUse).split(\"\"); //Convert to the base and create array.\r\n\t\tarray = array.map(function(x, i){return parseInt(x)}); //Convert to int array.\r\n\t\tstack.push(array); //Push array.\r\n\t}\r\n}"));
	}
	
	public static boolean isBuiltin(Token t){
		if(builtins == null) init();
		return builtins.containsKey(t.content);
	}
	
	public static String getBuiltinName(Token t){
		if(builtins == null) init();
		return builtins.get(t.content).name;
	}
	
	public static String getBuiltinHeader(Token t){
		if(builtins == null) init();
		return "var " + getBuiltinName(t) + " = " + builtins.get(t.content).function;
	}
}
